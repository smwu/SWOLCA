---
title: "Results Summary"
author: "Stephanie Wu"
date: "9/20/2022"
output:
  html_document: default
  pdf_document: default
---

```{r, echo=FALSE, message=FALSE, warning=FALSE}
setwd("/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Analysis_Code/")
#setwd("C:/Users/Lang/Documents/Harvard/Research/Briana/supRPC/wsOFMM/Toy_Example/")

library(R.matlab)
library(gtools)
library(flextable)
library(dplyr)
library(bayesplot)
library(ggplot2)
library(tidyr)
library(ggpubr)
library(gridExtra)
library(knitr)
library(kableExtra)
library(stringr)
library(abind)
library(gt)

### Helper functions

# get_true_params returns the observed simulated population values for the 
# parameters of interest
# Input: sim_pop: simulated population
# Outputs:
#   true_pi: Kx1 vector of true pi values
#   true_theta: pxKxd array of true theta values
#   true_xi: (S+K)x1 vector of true xi values
#   true_Phi_mat: SxK matrix of true outcome proportions P(Y=1|S=s,C=k)
get_true_params <- function(sim_pop) {
  true_pi <- tabulate(sim_pop$true_Ci) / length(sim_pop$true_Ci)
  theta_dim <- dim(sim_pop$true_global_thetas)
  true_theta <- array(NA, dim=theta_dim)
  for (j in 1:theta_dim[1]) {
    for (k in 1:theta_dim[2]) {
      for (r in 1:theta_dim[3]) {
        true_theta[j,k,r] <- sum((sim_pop$X_data[,j]==r) & (sim_pop$true_Ci==k)) / sum(sim_pop$true_Ci==k) 
      }
    }
  }
  true_xi <- sim_pop$true_xi
  S <- length(unique(sim_pop$true_Si))
  K <- length(unique(sim_pop$true_Ci))
  true_Phi_mat <- matrix(NA, nrow=S, ncol=K)
  for (s in 1:S) {
    for (k in 1:K) {
      true_Phi_mat[s,k] <- sum(sim_pop$Y_data==1 & sim_pop$true_Si==s & sim_pop$true_Ci==k) / sum(sim_pop$true_Si==s & sim_pop$true_Ci==k)
    }
  }
  
  return(list(true_pi = true_pi, true_theta = true_theta, true_xi = true_xi, true_Phi_mat = true_Phi_mat))
}

# get_theta_dist returns the squared Euclidean distance between the estimated 
# and true theta
# Inputs:
#   est_theta: estimated theta 3D array
#   true_theta: true theta 3D array
#   order: optimal ordering of estimated theta elements, determined in get_pi_dist()
# Outputs: a list with one element:
#   theta_dist: mean squared Euclidean distance between est_theta and true_theta 
#   over all iterations

    # est_theta <- analysis$theta_med
    # est_theta <- abind(est_theta, array(0.01, dim=dim(est_theta)[-2]), along=2)
    # true_theta <- true_params$true_theta
get_theta_dist <- function(est_theta, true_theta, order) {
  
  if (is.null(order)) {  # If no optimal ordering exists
    
    # Find all subsets of est_pi with size equal to true_pi
    all_perms <- permutations(n=dim(est_theta)[2], r=dim(true_theta)[2])
    
    # Obtain vector of dist (Frobenius norm) between est and true pi, calculated for each permutation
    dist_all_perms <- numeric(nrow(all_perms))
    for (i in 1:nrow(all_perms)) {
      est_theta_perm <- est_theta[,all_perms[i, ],]
      dist_all_perms[i] <- sum((est_theta_perm - true_theta)^2)
    }
    # Lowest dist out of all permutations
    min_dist <- min(dist_all_perms)
    # Obtain optimal ordering of classes
    ordering <- all_perms[which.min(dist_all_perms), ]
    
    # Return lowest dist and ordering
    return(list("theta_dist" = min_dist, "ordering" = ordering))
    
  } else {
    est_theta_perm <- est_theta[ , order, ]
    theta_dist <- sum((est_theta_perm - true_theta)^2)
    # Return dist
    return(list("theta_dist" = theta_dist))
  }
}


# get_pi_dist returns the squared Euclidean distance between the estimated and 
# true pi
# Inputs:
#   est_pi: estimated pi vector
#   true_pi: true pi vector
#   order: optimal ordering of estimated pi elements. If NULL, the best ordering 
#   is chosen over all permutations of est_pi with length equal to true_pi
# Outputs: a list with one element:
#   pi_dist: mean squared Euclidean distance between est_pi and true_pi over all
#   iterations
get_pi_dist <- function(est_pi, true_pi, order=NULL) {

  if (is.null(order)) {  # If no optimal ordering exists
    # Find all subsets of est_pi with size equal to true_pi
    all_perms <- permutations(n=length(est_pi), r=length(true_pi))
    
    # Obtain vector of dist between est and true pi, calculated for each permutation
    dist_all_perms <- numeric(nrow(all_perms))
    for (i in 1:nrow(all_perms)) {
      est_pi_perm <- est_pi[all_perms[i, ]]
      dist_all_perms[i] <- sum((est_pi_perm - true_pi)^2)
    }
    # Lowest dist out of all permutations
    min_dist <- min(dist_all_perms)
    # Obtain optimal ordering of classes
    ordering <- all_perms[which.min(dist_all_perms), ]
    
    # Return lowest dist and ordering
    return(list("pi_dist" = min_dist, "ordering" = ordering))
    
  } else {  # If optimal ordering exists
    est_pi_perm <- est_pi[order]
    pi_dist <- sum((est_pi_perm - true_pi)^2)
    
    # Return dist
    return(list("pi_dist" = pi_dist))
  }
}


# get_xi_dist returns the squared Euclidean distance between the estimated and 
# true xi, averaged over R sample iterations
# Inputs:
#   est_xi: estimated xi vector
#   true_xi: true xi vector
#   order: optimal ordering of estimated xi elements, determined in get_pi_dist()
#   S: number of coefficients corresponding to additional covariates
# Outputs: a list with one element:
#   xi_dist: mean squared Euclidean distance between est_xi and true_xi over all
#   iterations
get_xi_dist <- function(est_xi, true_xi, order, S) {
  # With factor variable coding
  K_mod <- length(order) 
  est_xi_perm <- numeric(length(est_xi))
  for (s in 1:S) {
    est_xi_perm[(s-1)*K_mod + (1:K_mod)] <- est_xi[(s-1)*K_mod + order]
  }
      # est_xi_perm <- c(est_xi[1:S], est_xi[order + S])
  xi_dist <- sum((est_xi_perm - true_xi)^2)
  
  # Return dist
  return(list("xi_dist" = xi_dist))
}

# get_Phi_dist returns the squared Euclidean distance between the estimated and 
# true Phi, calculated as the mean over all individuals
# Inputs:
#   est_Phi: estimated Phi vector; nx1
#   true_Phi: true Phi vector; nx1
#   order: optimal ordering of classes
#   S_i: vector of subpop assigns for all indivs
#   C_i: vector of class assigns for all indivs
# Outputs: a list with one element:
#   xi_dist: mean squared Euclidean distance between est_xi and true_xi over all
#   iterations
get_Phi_dist <- function(est_Phi, true_Phi) {
  
  Phi_dist <- mean((est_Phi - true_Phi)^2)
  # true_Phi_vector <- numeric(length(est_Phi))
  # for (i in 1:length(est_Phi)) {
  #   true_Phi_vector[i] <- true_Phi[S_i[i], order[C_i[i]]]
  # }
  # Phi_dist <- sum((est_Phi - true_Phi_vector)^2)
  
  # Return dist
  return(list("Phi_dist" = Phi_dist))
  
}


# get_Phi_order returns the optimal subset and ordering of the estimated Phi
# to match that of the true Phi
# Inputs:
#   est_Phi: estimated Phi vector
#   true_Phi: true Phi vector
# Output: vector of the estimated Phi with optimal subsetting and ordering 
get_Phi_order <- function(est_Phi, true_Phi) {
  # Find all subsets of est_pi with size equal to true_pi
  all_perms <- permutations(n=length(est_Phi), r=length(true_Phi))
  
  # Obtain vector of dist between est and true pi, calculated for each permutation
  dist_all_perms <- numeric(nrow(all_perms))
  for (i in 1:nrow(all_perms)) {
    est_Phi_perm <- est_Phi[all_perms[i, ]]
    dist_all_perms[i] <- sum((est_Phi_perm - true_Phi)^2)
  }
  # Obtain optimal ordering
  ordering <- all_perms[which.min(dist_all_perms), ]
  return(est_Phi[ordering])
}


# geom_hpline draws horizontal line segements for each point
# It can be used with the ggplot function
geom_hpline <- function(mapping = NULL, data = NULL,
                        stat = "identity", position = "identity",
                        ...,
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomHpline,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      na.rm = na.rm,
      ...
    )
  )
}

#' @rdname geom_hpline
#' @format NULL
#' @usage NULL
#' @export
GeomHpline <- ggproto("GeomHpline", GeomSegment,
                      required_aes = c("x", "y"),
                      non_missing_aes = c("size", "colour", "linetype", "width"),
                      default_aes = aes(
                        width = 0.5, colour = "black", size = 2, linetype = 1,
                        alpha = NA
                      ),
                      
                      draw_panel = function(self, data, panel_params, coord, arrow = NULL, arrow.fill = NULL,
                                            lineend = "butt", linejoin = "round", na.rm = FALSE) {
                        data <- mutate(data, x = x - width/2, xend = x + width, yend = y)
                        ggproto_parent(GeomSegment, self)$draw_panel(
                          data, panel_params, coord, arrow = arrow, arrow.fill = arrow.fill,
                          lineend = lineend, linejoin = linejoin, na.rm = na.rm
                        )
                      }
)


# get_MSE obtains the average squared Euclidean distance of the posterior 
# parameter estimates across the samples
# Inputs:
#   scen_pop: Population data scenario
#   scen_samp: Sample data scenario
#   iter_pop: Population data iteration
#   R_seq: Vector sequence of sample indices
#   latent: Boolean indicating if the latent method is used or not
#   posthoc: Boolean indicating if a posthoc pi is included in the results
# Outputs: list with the following components:
#   MSE_s: vector with mean squared Euclidean distances (MSE) of posterior 
#          parameter estimates from true values for the sOFMM model for pi, 
#          theta, xi, and posthoc pi if applicable
#   MSE: vector of MSEs for the sOFMM model for pi, theta, xi, and posthoc pi
#   MSE_K_s: mean squared distance of est K and true K across samples for sOFMM
#   MSE_K: mean squared distance of est K and true K across samples for wsOFMM
get_MSE <- function(data_dir, res_dir, scen_pop, scen_samp, iter_pop=1, R_seq, model, 
                    posthoc=FALSE, plot_pi=TRUE, plot_theta=TRUE, plot_xi=TRUE) {

  R <- length(R_seq)  # Number of samples
  
  # Initialize vectors
  K_dist <- pi_dist <- theta_dist <- xi_dist <- Phi_dist <- rep(NA, R)
  # Initial dist vector for pi for sOFMM with posthoc correction
  if (posthoc) {
    pi_dist_posthoc <- rep(NA, R)
  }
  
  # Load simulated population data
  sim_pop <- readMat(paste0(data_dir, "simdata_scen", scen_pop,"_iter", iter_pop, ".mat"))$sim.data
  names(sim_pop) <- str_replace_all(dimnames(sim_pop)[[1]], "[.]", "_")
  
  # Obtain true observed population parameters
  true_params <- get_true_params(sim_pop)
  
  if (plot_pi) {
    pi_all <- matrix(NA, nrow=R, ncol=sim_pop$true_K)
  }
  if (plot_theta) {
    theta_mode_all <- array(NA, dim=c(R, dim(sim_pop$true_global_patterns)))
    mode_mis_all <- rep(NA, R)
  }
  if (plot_xi) {
    xi_all <- matrix(NA, nrow=R, ncol=length(sim_pop$true_xi))
  }
  
  for (i in 1:R) {  # For each sample iteration
    samp_n = R_seq[i]
    
    sim_samp_path <- paste0(data_dir, "simdata_scen", scen_samp,"_iter", iter_pop, "_samp", samp_n, ".mat")
    sim_res_path <- paste0(res_dir, model, "_latent_results_scen", scen_samp, "_iter", iter_pop, "_samp", samp_n, ".mat")
    if (!file.exists(sim_samp_path) | !file.exists(sim_res_path)) {
      if (!file.exists(sim_samp_path)) {
        print(paste0("File does not exist: simdata_scen", scen_samp,"_iter", iter_pop, "_samp", samp_n))
      }
      if (!file.exists(sim_res_path)) {
        print(paste0("File does not exist: ", model, "_latent_results_scen", scen_samp, "_iter", iter_pop, "_samp", samp_n, ".mat"))
      }
    } else {
      
      # Load simulated sample data for the iteration
      sim_samp <- readMat(sim_samp_path)$sim.data
      names(sim_samp) <- str_replace_all(dimnames(sim_samp)[[1]], "[.]", "_")
      
      # Load model output and extract analysis portion
      output <- readMat(sim_res_path)
      analysis <- output$analysis
      names(analysis) <- str_replace_all(dimnames(analysis)[[1]], "[.]", "_")
      
      # If number of classes is incorrect, fill remaining components with 0's
      S <- length(unique(sim_samp$true_Si))
      if (analysis$k_red > sim_pop$true_K) {
        extra <- analysis$k_red - sim_pop$true_K
        true_params$true_pi <- c(true_params$true_pi, rep(0, extra))
        true_params$true_xi <- c(true_params$true_xi, rep(0, extra*S))
        filler <- array(0, dim=c(dim(analysis$theta_med)[1], extra, dim(analysis$theta_med)[3]))
        true_params$true_theta <- abind(true_params$true_theta, filler, along = 2)
      } else if (analysis$k_red < sim_pop$true_K) {
        missing <- sim_pop$true_K - analysis$k_red
        analysis$pi_med <- c(analysis$pi_med, rep(0, missing))
        analysis$xi_med <- c(analysis$xi_med, rep(0, missing*S))
        filler <- array(0, dim=c(dim(analysis$theta_med)[1], missing, dim(analysis$theta_med)[3]))
        analysis$theta_med <- abind(analysis$theta_med, filler, along = 2)      
      }
      
      # Get dist for number of classes
      K_dist[samp_n] <- (analysis$k_red - sim_pop$true_K)^2
      
      # Get dist (Eucl norm) for theta and optimal ordering
      theta_dist_temp <- get_theta_dist(analysis$theta_med, 
                                        true_params$true_theta, 
                                        order=NULL)
      theta_dist[samp_n] <- theta_dist_temp$theta_dist
      order <- theta_dist_temp$ordering
      
      if (plot_theta) {
        # Theta mode consumption levels for each item and class
        modes <- apply(analysis$theta_med[, order, ], c(1,2), which.max)
        if (analysis$k_red > sim_pop$true_K) { # mismatch of number of classes
          if (dim(theta_mode_all)[3] < analysis$k_red) {
            filler <- array(NA, dim=c(R, dim(analysis$theta_med)[1], extra))
            theta_mode_all <- abind(theta_mode_all, filler, along = 3)
          }
        }
        theta_mode_all[i,,1:analysis$k_red] <- modes
        # Mode mismatches
        mode_mis_all[i] <- sum(abs(modes - sim_pop$true_global_patterns))
      }
      
      ## Get dist for pi 
      pi_dist[samp_n] <- get_pi_dist(analysis$pi_med, true_params$true_pi, 
                                     order=order)$pi_dist
      if (posthoc) {
        pi_dist_posthoc[samp_n] <- get_pi_dist(data_s$posthoc_pi, true_params$true_pi, 
                                               order=order_s)$pi_dist
      } 
      if (plot_pi) {
        if (analysis$k_red > sim_pop$true_K) { # mismatch of number of classes
          if (dim(pi_all)[2] < analysis$k_red) {
            filler <- array(NA, dim=c(R, extra))
            pi_all <- abind(pi_all, filler, along = 2)
          }
        }
        pi_all[i,1:analysis$k_red] <- analysis$pi_med[order]
      }
      
      # Get dist for xi
      xi_dist[samp_n] <- get_xi_dist(analysis$xi_med, true_params$true_xi, 
                                     order, S)$xi_dist
      if (plot_xi) {
        if (analysis$k_red > sim_pop$true_K) { # mismatch of number of classes
          if (dim(xi_all)[2] < (S * analysis$k_red)) {
            filler <- array(NA, dim=c(R, S * extra))
            xi_all <- abind(xi_all, filler, along = 2)
          }
        }
        for (s in 1:S) {
          xi_all[i, (s-1)*analysis$k_red + (1:analysis$k_red)] <- analysis$xi_med[(s-1)*analysis$k_red + order]
        }
      }
      
      # # Get dist for Phi
      # # Get true Phi for the sample
      # n <- length(sim_samp$true_Ci)
      # true_Phi <- numeric(n)
      # for (i in 1:n) {
      #   true_Phi[i] <- true_params$true_Phi_mat[sim_samp$true_Si[i], sim_samp$true_Ci[i]]
      # }
      # Phi_dist[samp_n] <- get_Phi_dist(analysis$Phi_med, true_Phi)$Phi_dist
      # Phi_dist_s[samp_n] <- get_Phi_dist(data_s$Phi_med, true_Phi)$Phi_dist
    }
  }
    # Obtain MSE by taking the mean over the independent samples
    K_MSE <- mean(K_dist, na.rm = TRUE)
    pi_MSE <- mean(pi_dist, na.rm = TRUE)
    theta_MSE <- mean(theta_dist, na.rm = TRUE)
    xi_MSE <- mean(xi_dist, na.rm = TRUE)
      # K_MSE <- sqrt(mean(K_dist))
      # pi_MSE <- sqrt(mean(pi_dist))
      # theta_MSE <- sqrt(mean(theta_dist))
      # xi_MSE <- sqrt(mean(xi_dist))
  
  ret_list <- list(K_MSE = K_MSE, pi_MSE = pi_MSE, theta_MSE = theta_MSE, xi_MSE = xi_MSE)
  if (posthoc) {
    posthoc_pi_MSE <- mean(pi_dist_posthoc)
    ret_list[["posthoc_pi_MSE"]] <- posthoc_pi_MSE
  } 
  if (plot_pi) {
    ret_list[["pi_all"]] <- pi_all
  }
  if (plot_theta) {
    theta_mode <- apply(theta_mode_all, c(2,3), function(x) mean(x, na.rm = TRUE))
    mode_mis <- mean(mode_mis_all, na.rm = TRUE)
    ret_list[["theta_mode"]] <- theta_mode
    ret_list[["mode_mis"]] <- mode_mis
  }
  if (plot_xi) {
    ret_list[["xi_all"]] <- xi_all
  }
  return(ret_list)
}
```


## MSE for posterior parameters: squared Euclidean distance averaged across samples

### Baseline scenario
```{r, echo=FALSE, cache=TRUE}
data_dir <- "/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Data/"
res_dir <- "/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Results/"
scen_pop=1
scen_samp=101
iter_pop=1
R_seq=1:100
posthoc=FALSE

MSE_SRS_ws <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=101, 
                      iter_pop=iter_pop, R_seq=R_seq, model="wsOFMM")
MSE_SRS_s <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=101, 
                      iter_pop=iter_pop, R_seq=R_seq, model="sOFMM")
MSE_Strat_ws <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=201, 
                      iter_pop=iter_pop, R_seq=R_seq, model="wsOFMM")
MSE_Strat_s <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=201, 
                     iter_pop=iter_pop, R_seq=R_seq, model="sOFMM")
```

#### Create table
```{r, echo=FALSE}
### Create table of MSEs
MSE_summ <- as.data.frame(matrix(NA, nrow=4, ncol=6))
colnames(MSE_summ) <- c("Sampling Scheme", "Model", "K", "$\\pi$", "$\\theta$", "$\\xi$")
MSE_summ[, 1] <- c(rep("SRS", 2), rep("Stratified", 2))
MSE_summ[, 2] <- rep(c("Unweighted(sOFMM)", "Weighted(wsOFMM)"), 2)  ## latent versions
MSE_summ[1, -c(1,2)] <- c(MSE_SRS_s[1:4])
MSE_summ[2, -c(1,2)] <- c(MSE_SRS_ws[1:4])
MSE_summ[3, -c(1,2)] <- c(MSE_Strat_s[1:4])
MSE_summ[4, -c(1,2)] <- c(MSE_Strat_ws[1:4])
# kable(MSE_summ, format = "html", booktabs = TRUE, 
#       format.args=list(scientific=TRUE),
#       caption = "MSE of posterior parameter estimates comparing unweighted and 
#       weighted model performance for simple random sampling and unequal probability 
#       stratified random sampling, averaged over 100 samples")

MSE_summ %>% 
  gt(caption = "Baseline scenario MSE of posterior parameter estimates, averaged over 100 samples") %>%
  cols_label("$\\pi$" = "π", "$\\theta$" = "θ", "$\\xi$" = "ξ") %>%
  fmt_scientific(
    columns = 3:6,
    decimals = 3
  ) 
  
```

#### Plot pi as grouped boxplot over iterations
```{r, echo=FALSE}
data_dir <- "/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Data/"
scen_pop=1
iter_pop=1
sim_pop <- readMat(paste0(data_dir, "simdata_scen", scen_pop,"_iter", iter_pop, ".mat"))$sim.data
names(sim_pop) <- str_replace_all(dimnames(sim_pop)[[1]], "[.]", "_")

# Obtain true observed population parameters
true_params <- get_true_params(sim_pop)


R <- length(R_seq)
pi_plot_data <- as.data.frame(rbind(MSE_Strat_s$pi_all,  MSE_Strat_ws$pi_all))
if (any(is.na(pi_plot_data))) {
  colnames(pi_plot_data) <- paste0("pi_", 1:ncol(pi_plot_data))
  pi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R))
  pi_plot_data <- pi_plot_data %>% gather("pi_component", "value", -Model)
  pi_plot_data <- pi_plot_data %>% group_by(Model, pi_component) %>% mutate(num_points = sum(!is.na(value)))
  ggplot(pi_plot_data, aes(x=pi_component, y=value, fill=Model, alpha=factor(num_points))) +
    theme_bw() +
    geom_boxplot() +
    scale_alpha_discrete(range = c(0.2, 1), guide = guide_legend(override.aes = list(fill = "black"),
                         title = "Number of Observations")) +
    geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_params$true_pi[1], yend=true_params$true_pi[1]),color="forestgreen") +
    geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_params$true_pi[2], yend=true_params$true_pi[2]),color="forestgreen") +
    geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_params$true_pi[3], yend=true_params$true_pi[3]),color="forestgreen") +
    ggtitle("Parameter estimation for pi under stratified sampling with \nunequal probabilities, displayed across 100 samples")
} else {
  colnames(pi_plot_data) <- paste0("pi_", 1:ncol(pi_plot_data))
  pi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R))
  pi_plot_data <- pi_plot_data %>% gather("pi_component", "value", -Model)
  ggplot(pi_plot_data, aes(x=pi_component, y=value, fill=Model)) +
    theme_bw() +
    geom_boxplot() +
    geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_params$true_pi[1], yend=true_params$true_pi[1]),color="forestgreen") +
    geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_params$true_pi[2], yend=true_params$true_pi[2]),color="forestgreen") +
    geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_params$true_pi[3], yend=true_params$true_pi[3]),color="forestgreen") +
    ggtitle("Parameter estimation for pi under stratified sampling with \nunequal probabilities, displayed across 100 samples")
}

```
### Plot xi over 100 iterations

```{r, echo=FALSE}
xi_plot_data <- as.data.frame(rbind(MSE_Strat_s$xi_all,  MSE_Strat_ws$xi_all))
colnames(xi_plot_data) <- c("xi_1", "xi_2", "xi_3", "xi_4", "xi_5", "xi_6")
xi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R))
xi_plot_data <- xi_plot_data %>% gather("xi_component", "value", 1:6)
ggplot(xi_plot_data, aes(x=xi_component, y=value, fill=Model)) +
  theme_bw() +
  geom_boxplot() +
  geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_params$true_xi[1], yend=true_params$true_xi[1]),color="forestgreen") +
  geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_params$true_xi[2], yend=true_params$true_xi[2]),color="forestgreen") +
  geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_params$true_xi[3], yend=true_params$true_xi[3]),color="forestgreen") +
    geom_segment(mapping=aes(x=3.5, xend=4.5, y=true_params$true_xi[4], yend=true_params$true_xi[4]),color="forestgreen") +
  geom_segment(mapping=aes(x=4.5, xend=5.5, y=true_params$true_xi[5], yend=true_params$true_xi[5]),color="forestgreen") +
  geom_segment(mapping=aes(x=5.5, xend=6.5, y=true_params$true_xi[6], yend=true_params$true_xi[6]),color="forestgreen") +
  ggtitle("Parameter estimation for xi under stratified sampling with unequal probabilities, \ndisplayed across 100 samples")

```

```{r, echo=FALSE}
Item <- factor(as.character(1:30), levels = as.character(30:1))
theta_plot_data <- data.frame(MSE_Strat_s$theta_mode, Item)
colnames(theta_plot_data) <- c(1:3, "Item")
theta_plot_data <- theta_plot_data %>% gather("Class", "Level", 1:3)

theta_mode_plot <- function(theta_plot_data, x_label) {
  p <- dim(theta_plot_data)[1]
  K <- dim(theta_plot_data)[2]
  Item <- factor(as.character(1:p), levels = as.character(p:1))
  theta_plot_data <- data.frame(theta_plot_data, Item)
  colnames(theta_plot_data) <- c(1:3, "Item")
  theta_plot_data <- theta_plot_data %>% gather("Class", "Level", 1:3) 
  patterns <- ggplot(theta_plot_data, aes(x=Class, y=Item, fill=Level)) + 
            theme_classic() +
            xlab(x_label) +
            geom_tile(color="gray") + 
            geom_text(aes(label = Level), col="white", cex=2) +
            scale_fill_gradient(trans = "reverse")
  return(patterns)
}

p_true <- theta_mode_plot(sim_pop$true_global_patterns, "True Classes")
p_sOFMM <- theta_mode_plot(MSE_Strat_s$theta_mode, "sOFMM Classes")
p_wsOFMM <- theta_mode_plot(MSE_Strat_ws$theta_mode, "wsOFMM Classes")
p_comb <- ggarrange(p_true, p_sOFMM + theme(axis.title.y = element_blank()), 
                    p_wsOFMM + theme(axis.title.y = element_blank()), nrow = 1, 
                    common.legend = TRUE, legend = "right")
annotate_figure(p_comb, 
  top = text_grob("Pattern elicitation under stratified sampling with unequal probabilities, averaged across 100 samples"))
```

```{r, echo=FALSE}
Phi_plot_data <- as.data.frame(rbind(pnorm(MSE_Strat_s$xi_all),  pnorm(MSE_Strat_ws$xi_all)))
colnames(Phi_plot_data) <- c("(S=1,C=1)", "(S=1,C=2)", "(S=1,C=3)", "(S=2,C=1)", "(S=2,C=2)", "(S=2,C=3)")
Phi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R))
Phi_plot_data <- Phi_plot_data %>% gather("Phi_component", "value", 1:6)
true_Phi <- pnorm(true_params$true_xi)
ggplot(Phi_plot_data, aes(x=Phi_component, y=value, fill=Model)) +
  theme_bw() +
  geom_boxplot() +
  ylab("P(Y=1|S,C)") +
  geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_Phi[1], yend=true_Phi[1]),color="forestgreen") +
  geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_Phi[2], yend=true_Phi[2]),color="forestgreen") +
  geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_Phi[3], yend=true_Phi[3]),color="forestgreen") +
    geom_segment(mapping=aes(x=3.5, xend=4.5, y=true_Phi[4], yend=true_Phi[4]),color="forestgreen") +
  geom_segment(mapping=aes(x=4.5, xend=5.5, y=true_Phi[5], yend=true_Phi[5]),color="forestgreen") +
  geom_segment(mapping=aes(x=5.5, xend=6.5, y=true_Phi[6], yend=true_Phi[6]),color="forestgreen") +
  ggtitle("Parameter estimation for Phi under stratified sampling with unequal probabilities, \ndisplayed across 100 samples")

```

### Supervised scenario
```{r, echo=FALSE, cache=TRUE}
MSE_Sup_SRS_ws <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=102, 
                      iter_pop=iter_pop, R_seq=R_seq, model="wsOFMM")
MSE_Sup_SRS_s <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=102, 
                      iter_pop=iter_pop, R_seq=R_seq, model="sOFMM")
MSE_Sup_Strat_ws <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=202, 
                      iter_pop=iter_pop, R_seq=R_seq, model="wsOFMM")
MSE_Sup_Strat_s <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=202, 
                     iter_pop=iter_pop, R_seq=R_seq, model="sOFMM")
```

```{r, echo=FALSE}
### Create table of MSEs
MSE_summ <- as.data.frame(matrix(NA, nrow=4, ncol=6))
colnames(MSE_summ) <- c("Sampling Scheme", "Model", "K", "$\\pi$", "$\\theta$", "$\\xi$")
MSE_summ[, 1] <- c(rep("SRS", 2), rep("Stratified", 2))
MSE_summ[, 2] <- rep(c("Unweighted(sOFMM)", "Weighted(wsOFMM)"), 2)  ## latent versions
MSE_summ[1, -c(1,2)] <- c(MSE_Sup_SRS_s[1:4])
MSE_summ[2, -c(1,2)] <- c(MSE_Sup_SRS_ws[1:4])
MSE_summ[3, -c(1,2)] <- c(MSE_Sup_Strat_s[1:4])
MSE_summ[4, -c(1,2)] <- c(MSE_Sup_Strat_ws[1:4])
# kable(MSE_summ, format = "latex", booktabs = TRUE, 
#       format.args=list(scientific=TRUE),
#       caption = "MSE of posterior parameter estimates comparing unweighted and 
#       weighted model performance for simple random sampling and unequal probability 
#       stratified random sampling, averaged over 100 samples")

MSE_summ %>% 
  gt(caption = "Supervised scenario MSE of posterior parameter estimates, averaged over 100 samples") %>%
  cols_label("$\\pi$" = "π", "$\\theta$" = "θ", "$\\xi$" = "ξ") %>%
  fmt_scientific(
    columns = 3:6,
    decimals = 3
  ) 
```







## Plotting
```{r}
    ### Parameter boxplots
    ### Theta
    # Reorder columns of estimated theta to match classes of true theta
    # Number of classes set to 2
    # wsOFMM
    true_theta_dim <- dim(true_params$true_theta)
    theta_red_order_ws <- data_ws$theta_red[, , order_ws, ]
    df_theta_order_ws <- data.frame(theta_red_order_ws)
    colnames(df_theta_order_ws) <- paste0(paste0("(", 1:theta_dim_ws[2], ",", 
                      rep(1:true_theta_dim[2], each=theta_dim_ws[2])), 
               ",", rep(1:theta_dim_ws[4],
                        each=(theta_dim_ws[2]*true_theta_dim[2])),")")
    reorder_theta_names <- paste0(rep(paste0("(",1:theta_dim_ws[2],","), 
                                      each=(true_theta_dim[2]*theta_dim_ws[4])), 
                                  paste0(rep(1:true_theta_dim[2],
                                             each=theta_dim_ws[4]),",",
                                         paste0(1:theta_dim_ws[4], ")")))
    df_theta_order_ws <- df_theta_order_ws[, reorder_theta_names]
    # sOFMM
    theta_red_order_s <- data_s$theta_red[, , order_s, ]
    df_theta_order_s <- data.frame(theta_red_order_s)
    colnames(df_theta_order_s) <- paste0(paste0("(", 1:theta_dim_s[2], ",", 
                      rep(1:true_theta_dim[2], each=theta_dim_s[2])), 
               ",", rep(1:theta_dim_s[4], each=(theta_dim_s[2]*true_theta_dim[2])),")")
    df_theta_order_s <- df_theta_order_s[, reorder_theta_names]
    # Restrict to food item j=1
    df_theta_order_ws <- df_theta_order_ws[, 1:4]
    df_theta_order_s <- df_theta_order_s[, 1:4]
    
    # Reshape theta matrix for plotting
    reshape_theta_order_ws <- df_theta_order_ws %>%
      gather("theta", "theta_value")
    reshape_theta_order_s <- df_theta_order_s %>%
      gather("theta", "theta_value")  
    reshape_theta_order <- rbind(reshape_theta_order_s, reshape_theta_order_ws)
    reshape_theta_order$Model <- c(rep("sOFMM", times=nrow(reshape_theta_order_s)), 
                           rep("wsOFMM", times=nrow(reshape_theta_order_ws)))
    
    # Get data frame of true thetas
    true_theta_df <- t(data.frame(unlist(data.frame(true_params$true_theta))))
    rownames(true_theta_df) <- NULL
    colnames(true_theta_df) <- paste0(paste0("(", 1:theta_dim_ws[2], ",", 
                rep(1:true_theta_dim[2], each=theta_dim_ws[2])), 
         ",", rep(1:theta_dim_ws[4], each=(theta_dim_ws[2]*true_theta_dim[2])),")")
    true_theta_df <- true_theta_df[, reorder_theta_names]
    true_theta_df <- as.data.frame(true_theta_df)
    colnames(true_theta_df) <- "theta_value"
    true_theta_df$theta <- rownames(true_theta_df)
    # Restrict to food item j=1
    true_theta_df <- true_theta_df[1:4, ]
    
    # Create paired boxplots
    p <- ggplot(data=reshape_theta_order, aes(x=theta, y=theta_value)) +
      geom_boxplot(aes(fill=Model)) + 
      ggtitle(paste0("theta sample ", select_samp)) +
      geom_hpline(aes(x=theta, y=theta_value, linetype="Population"), 
                  data=true_theta_df, color="forestgreen", size=1.2, width=0.9) +   
      theme_bw() + 
      theme(axis.text.x=element_text(angle=20), 
            plot.title = element_text(hjust = 0.5),
            legend.position="none") + 
      xlab("theta(j,k,r)") +
      scale_linetype_manual(name = "True Values", values=1,
                        guide = guide_legend(override.aes = 
                                               list(color = c("forestgreen"))))
    
    boxplot_theta[[i]] <- p  

```
