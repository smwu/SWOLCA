---
title: "Results Summary"
author: "Stephanie Wu"
date: "9/20/2022"
output:
  html_document: default
  pdf_document: default
---

```{r, echo=FALSE, message=FALSE, warning=FALSE}
setwd("/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Analysis_Code/")
#setwd("C:/Users/Lang/Documents/Harvard/Research/Briana/supRPC/wsOFMM/Toy_Example/")

library(R.matlab)
library(gtools)
library(flextable)
library(dplyr)
library(bayesplot)
library(ggplot2)
library(tidyr)
library(ggpubr)
library(gridExtra)
library(knitr)
library(kableExtra)
library(stringr)
library(abind)
library(gt)

### Helper functions

# get_true_params returns the observed simulated population values for the 
# parameters of interest
# Input: sim_pop: simulated population
# Outputs:
#   true_pi: Kx1 vector of true pi values
#   true_theta: pxKxd array of true theta values
#   true_xi: (S+K)x1 vector of true xi values
#   true_Phi_mat: SxK matrix of true outcome proportions P(Y=1|S=s,C=k)
get_true_params <- function(sim_pop) {
  true_pi <- tabulate(sim_pop$true_Ci) / length(sim_pop$true_Ci)
  theta_dim <- dim(sim_pop$true_global_thetas)
  true_theta <- array(NA, dim=theta_dim)
  for (j in 1:theta_dim[1]) {
    for (k in 1:theta_dim[2]) {
      for (r in 1:theta_dim[3]) {
        true_theta[j,k,r] <- sum((sim_pop$X_data[,j]==r) & (sim_pop$true_Ci==k)) / sum(sim_pop$true_Ci==k) 
      }
    }
  }
  true_xi <- sim_pop$true_xi
  S <- length(unique(sim_pop$true_Si))
  K <- length(unique(sim_pop$true_Ci))
  true_Phi_mat <- matrix(NA, nrow=S, ncol=K)
  for (s in 1:S) {
    for (k in 1:K) {
      true_Phi_mat[s,k] <- sum(sim_pop$Y_data==1 & sim_pop$true_Si==s & sim_pop$true_Ci==k) / sum(sim_pop$true_Si==s & sim_pop$true_Ci==k)
    }
  }
  
  return(list(true_pi = true_pi, true_theta = true_theta, true_xi = true_xi, true_Phi_mat = true_Phi_mat))
}

# get_theta_dist returns the squared Euclidean distance between the estimated 
# and true theta
# Inputs:
#   est_theta: estimated theta 3D array
#   true_theta: true theta 3D array
#   order: optimal ordering of estimated theta elements, determined in get_pi_dist()
# Outputs: a list with one element:
#   theta_dist: mean squared Euclidean distance between est_theta and true_theta 
#   over all iterations

    # est_theta <- analysis$theta_med
    # est_theta <- abind(est_theta, array(0.01, dim=dim(est_theta)[-2]), along=2)
    # true_theta <- true_params$true_theta
get_theta_dist <- function(est_theta, true_theta, order) {
  
  if (is.null(order)) {  # If no optimal ordering exists
    
    # Find all subsets of est_pi with size equal to true_pi
    all_perms <- permutations(n=dim(est_theta)[2], r=dim(true_theta)[2])
    
    # Obtain vector of dist (Frobenius norm) between est and true pi, calculated for each permutation
    dist_all_perms <- numeric(nrow(all_perms))
    for (i in 1:nrow(all_perms)) {
      est_theta_perm <- est_theta[,all_perms[i, ],]
      dist_all_perms[i] <- sum((est_theta_perm - true_theta)^2)
    }
    # Lowest dist out of all permutations
    min_dist <- min(dist_all_perms)
    # Obtain optimal ordering of classes
    ordering <- all_perms[which.min(dist_all_perms), ]
    est_theta_perm <- est_theta[ , order, ]
    
    # Return lowest dist, ordering, and reordered estimate
    return(list("theta_dist" = min_dist, "ordering" = ordering, "est_theta_perm" = est_theta_perm))
    
  } else {
    est_theta_perm <- est_theta[ , order, ]
    theta_dist <- sum((est_theta_perm - true_theta)^2)
    # Return dist and reordered estimate
    return(list("theta_dist" = theta_dist, "est_theta_perm" = est_theta_perm))
  }
}


# get_pi_dist returns the squared Euclidean distance between the estimated and 
# true pi
# Inputs:
#   est_pi: estimated pi vector
#   true_pi: true pi vector
#   order: optimal ordering of estimated pi elements. If NULL, the best ordering 
#   is chosen over all permutations of est_pi with length equal to true_pi
# Outputs: a list with one element:
#   pi_dist: mean squared Euclidean distance between est_pi and true_pi over all
#   iterations
get_pi_dist <- function(est_pi, true_pi, order=NULL) {

  if (is.null(order)) {  # If no optimal ordering exists
    # Find all subsets of est_pi with size equal to true_pi
    all_perms <- permutations(n=length(est_pi), r=length(true_pi))
    
    # Obtain vector of dist between est and true pi, calculated for each permutation
    dist_all_perms <- numeric(nrow(all_perms))
    for (i in 1:nrow(all_perms)) {
      est_pi_perm <- est_pi[all_perms[i, ]]
      dist_all_perms[i] <- sum((est_pi_perm - true_pi)^2)
    }
    # Lowest dist out of all permutations
    min_dist <- min(dist_all_perms)
    # Obtain optimal ordering of classes
    ordering <- all_perms[which.min(dist_all_perms), ]
    est_pi_perm <- est_pi[ordering]
    
    # Return lowest dist, ordering, and reordered estimate
    return(list("pi_dist" = min_dist, "ordering" = ordering, "est_pi_perm" = est_pi_perm))
    
  } else {  # If optimal ordering exists
    est_pi_perm <- est_pi[order]
    pi_dist <- sum((est_pi_perm - true_pi)^2)
    
    # Return dist and reordered estimate
    return(list("pi_dist" = pi_dist, "est_pi_perm" = est_pi_perm))
  }
}


# get_xi_dist returns the squared Euclidean distance between the estimated and 
# true xi, averaged over R sample iterations
# Inputs:
#   est_xi: estimated xi vector
#   true_xi: true xi vector
#   order: optimal ordering of estimated xi elements, determined in get_pi_dist()
#   S: number of coefficients corresponding to additional covariates
# Outputs: a list with one element:
#   xi_dist: mean squared Euclidean distance between est_xi and true_xi over all
#   iterations
get_xi_dist <- function(est_xi, true_xi, order, S) {
  # With factor variable coding
  K_mod <- length(order) 
  est_xi_perm <- numeric(length(est_xi))
  for (s in 1:S) {
    est_xi_perm[(s-1)*K_mod + (1:K_mod)] <- est_xi[(s-1)*K_mod + order]
  }
      # est_xi_perm <- c(est_xi[1:S], est_xi[order + S])
  xi_dist <- sum((est_xi_perm - true_xi)^2)
  
  # Return dist and reordered estimate
  return(list("xi_dist" = xi_dist, "est_xi_perm" = est_xi_perm))
}

# get_Phi_dist returns the squared Euclidean distance between the estimated and 
# true Phi, calculated as the mean over all individuals
# Inputs:
#   est_Phi: estimated Phi vector; nx1
#   true_Phi: true Phi vector; nx1
#   order: optimal ordering of classes
#   S_i: vector of subpop assigns for all indivs
#   C_i: vector of class assigns for all indivs
# Outputs: a list with one element:
#   xi_dist: mean squared Euclidean distance between est_xi and true_xi over all
#   iterations
get_Phi_dist <- function(est_Phi, true_Phi) {
  
  Phi_dist <- mean((est_Phi - true_Phi)^2)
  # true_Phi_vector <- numeric(length(est_Phi))
  # for (i in 1:length(est_Phi)) {
  #   true_Phi_vector[i] <- true_Phi[S_i[i], order[C_i[i]]]
  # }
  # Phi_dist <- sum((est_Phi - true_Phi_vector)^2)
  
  # Return dist
  return(list("Phi_dist" = Phi_dist))
  
}


# get_Phi_order returns the optimal subset and ordering of the estimated Phi
# to match that of the true Phi
# Inputs:
#   est_Phi: estimated Phi vector
#   true_Phi: true Phi vector
# Output: vector of the estimated Phi with optimal subsetting and ordering 
get_Phi_order <- function(est_Phi, true_Phi) {
  # Find all subsets of est_pi with size equal to true_pi
  all_perms <- permutations(n=length(est_Phi), r=length(true_Phi))
  
  # Obtain vector of dist between est and true pi, calculated for each permutation
  dist_all_perms <- numeric(nrow(all_perms))
  for (i in 1:nrow(all_perms)) {
    est_Phi_perm <- est_Phi[all_perms[i, ]]
    dist_all_perms[i] <- sum((est_Phi_perm - true_Phi)^2)
  }
  # Obtain optimal ordering
  ordering <- all_perms[which.min(dist_all_perms), ]
  return(est_Phi[ordering])
}


# geom_hpline draws horizontal line segements for each point
# It can be used with the ggplot function
geom_hpline <- function(mapping = NULL, data = NULL,
                        stat = "identity", position = "identity",
                        ...,
                        na.rm = FALSE,
                        show.legend = NA,
                        inherit.aes = TRUE) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomHpline,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      na.rm = na.rm,
      ...
    )
  )
}

#' @rdname geom_hpline
#' @format NULL
#' @usage NULL
#' @export
GeomHpline <- ggproto("GeomHpline", GeomSegment,
                      required_aes = c("x", "y"),
                      non_missing_aes = c("size", "colour", "linetype", "width"),
                      default_aes = aes(
                        width = 0.5, colour = "black", size = 2, linetype = 1,
                        alpha = NA
                      ),
                      
                      draw_panel = function(self, data, panel_params, coord, arrow = NULL, arrow.fill = NULL,
                                            lineend = "butt", linejoin = "round", na.rm = FALSE) {
                        data <- mutate(data, x = x - width/2, xend = x + width, yend = y)
                        ggproto_parent(GeomSegment, self)$draw_panel(
                          data, panel_params, coord, arrow = arrow, arrow.fill = arrow.fill,
                          lineend = lineend, linejoin = linejoin, na.rm = na.rm
                        )
                      }
)
```

```{r, echo=FALSE}
# get_MSE obtains the average squared Euclidean distance of the posterior 
# parameter estimates across the samples
# Inputs:
#   scen_pop: Population data scenario
#   scen_samp: Sample data scenario
#   iter_pop: Population data iteration
#   R_seq: Vector sequence of sample indices
#   model: String indicating type of model, e.g., "wsOFMM", "sOFMM", "wOFMM"
#   coverage: Boolean indicating if coverage intervals should be calculated
#   adjust: Boolean whether post-processing adjusted estimates should be used
#   posthoc: Boolean indicating if a posthoc pi is included in the results
#   plot_pi: Boolean indicating if output for pi plots is needed
#   plot_theta: Boolean indicating if output for theta plots is needed
#   plot_xi: Boolean indicating if output for xi plots is needed
# Outputs: list with the following components:
#   K_MSE: MSE for number of clusters K
#   pi_MSE: MSE for cluster probabilities pi
#   theta_MSE: MSE for item response probabilities theta
#   xi_MSE: MSE for probit coefficients xi
#   posthoc_pi_MSE: if posthoc = TRUE, MSE for pi applying weights posthoc
#   pi_all: if plot_pi = TRUE, estimated pi values across samples
#   theta_mode: if plot_theta = TRUE, estimate modal theta values across samples
#   mode_mis: if plot_theta = TRUE, number of modal mismatches compared to true theta
#   xi_all: if plot_xi = TRUE, estimated xi values across samples
#   pi_cover_avg: if coverage = TRUE, coverage of pi estimate
#   theta_cover_avg: if coverage = TRUE, coverage of theta estimate
#   xi_cover_avg: if coverage = TRUE, coverage of xi estimate
get_MSE <- function(data_dir, res_dir, scen_pop, scen_samp, iter_pop=1, R_seq, model, 
                    coverage = TRUE, adjust = TRUE,
                    posthoc=FALSE, plot_pi=TRUE, plot_theta=TRUE, plot_xi=TRUE) {
  R <- length(R_seq)  # Number of samples
  
  # Initialize vectors
  K_dist <- pi_dist <- theta_dist <- xi_dist <- Phi_dist <- rep(NA, R)
  
  # Initial dist vector for pi for sOFMM with posthoc correction
  if (posthoc) {
    pi_dist_posthoc <- rep(NA, R)
  }
  
  # Load simulated population data
  sim_pop <- readMat(paste0(data_dir, "simdata_scen", scen_pop,"_iter", iter_pop, ".mat"))$sim.data
  names(sim_pop) <- str_replace_all(dimnames(sim_pop)[[1]], "[.]", "_")
  
  # Obtain true observed population parameters
  true_params <- get_true_params(sim_pop)
  
  # Initialize coverage vectors
  if (coverage) {
    pi_cover <- matrix(NA, nrow=R, ncol=length(true_params$true_pi))
    theta_cover <- array(NA, c(R, dim(true_params$true_theta)[c(1,2)]))
    xi_cover <- matrix(NA, nrow=R, ncol=length(true_params$true_xi))
  }
  
  # Initialize plotting structures
  if (plot_pi) {
    pi_all <- matrix(NA, nrow=R, ncol=sim_pop$true_K)
  }
  if (plot_theta) {
    theta_mode_all <- array(NA, dim=c(R, dim(sim_pop$true_global_patterns)))
    mode_mis_all <- rep(NA, R)
  }
  if (plot_xi) {
    xi_all <- matrix(NA, nrow=R, ncol=length(sim_pop$true_xi))
  }
  
  
  # For each sample iteration
  for (i in 1:R) { 
    samp_n = R_seq[i]
    
    sim_samp_path <- paste0(data_dir, "simdata_scen", scen_samp,"_iter", iter_pop, "_samp", samp_n, ".mat")
    sim_res_path <- paste0(res_dir, model, "_latent_results_scen", scen_samp, "_iter", iter_pop, "_samp", samp_n, ".mat")
    if (!file.exists(sim_samp_path) | !file.exists(sim_res_path)) {
      if (!file.exists(sim_samp_path)) {
        print(paste0("File does not exist: simdata_scen", scen_samp,"_iter", iter_pop, "_samp", samp_n))
      }
      if (!file.exists(sim_res_path)) {
        print(paste0("File does not exist: ", model, "_latent_results_scen", scen_samp, "_iter", iter_pop, "_samp", samp_n, ".mat"))
      }
    } else {
      
      # If post-processing adjustment has been applied, use the adjusted RData
      if (adjust) {
        sim_adj_path <- paste0(res_dir, model, "_latent_results_adj_scen", scen_samp, "_iter", iter_pop, "_samp", samp_n, ".RData")
        load(sim_adj_path)
      # If no post-processing, read in Matlab data
      } else {
        # Load simulated sample data for the iteration
        sim_samp <- readMat(sim_samp_path)$sim.data
        names(sim_samp) <- str_replace_all(dimnames(sim_samp)[[1]], "[.]", "_")
        
        # Load model output and extract analysis portion
        output <- readMat(sim_res_path)
        analysis <- output$analysis
        names(analysis) <- str_replace_all(dimnames(analysis)[[1]], "[.]", "_")
      }
      
      # If number of classes is incorrect, fill remaining components with 0's
      S <- length(unique(sim_samp$true_Si))
      if (analysis$k_red > sim_pop$true_K) {
        extra <- analysis$k_red - sim_pop$true_K
        true_params$true_pi <- c(true_params$true_pi, rep(0, extra))
        true_params$true_xi <- c(true_params$true_xi, rep(0, extra*S))
        filler <- array(0, dim=c(dim(analysis$theta_med)[1], extra, dim(analysis$theta_med)[3]))
        true_params$true_theta <- abind(true_params$true_theta, filler, along = 2)
      } else if (analysis$k_red < sim_pop$true_K) {
        missing <- sim_pop$true_K - analysis$k_red
        analysis$pi_med <- c(analysis$pi_med, rep(0, missing))
        analysis$xi_med <- c(analysis$xi_med, rep(0, missing*S))
        filler <- array(0, dim=c(dim(analysis$theta_med)[1], missing, dim(analysis$theta_med)[3]))
        analysis$theta_med <- abind(analysis$theta_med, filler, along = 2)      
      }
      
      true_K <- as.vector(sim_pop$true_K)
      
      ########### Distance estimates for MSE ###############
      ##### Number of classes, K
      K_dist[samp_n] <- (analysis$k_red - sim_pop$true_K)^2
      
      ##### theta: get dist (Eucl norm) and optimal ordering
      theta_perm <- get_theta_dist(analysis$theta_med, 
                                        true_params$true_theta, 
                                        order=NULL)
      theta_dist[samp_n] <- theta_perm$theta_dist
      order <- theta_perm$ordering
      # Theta mode consumption levels for each item and class (pxK)
      est_modes <- apply(analysis$theta_med[, order, ], c(1,2), which.max)
      true_modes <- apply(true_params$true_theta[, order, ], c(1,2), which.max)
      # True modal probabilities for each item and class (pxK)
      true_theta_modal <- apply(true_params$true_theta[, order, ], c(1,2), max)
      
      ##### pi 
      pi_perm <- get_pi_dist(analysis$pi_med, true_params$true_pi, order=order)
      pi_dist[samp_n] <- pi_perm$pi_dist
      if (posthoc) {
        pi_dist_posthoc[samp_n] <- get_pi_dist(data_s$posthoc_pi, true_params$true_pi, 
                                               order=order_s)$pi_dist
      } 
      
      ##### xi
      xi_perm <- get_xi_dist(analysis$xi_med, true_params$true_xi, order, S)
      xi_dist[samp_n] <- xi_perm$xi_dist
      
      ############ Coverage probabilities #################
      if (coverage) {
        M <- dim(analysis$theta_red)[1]
        p <- dim(analysis$theta_red)[2]
        K <- sim_pop$true_K
        
        ##### pi
        # Obtain credible intervals for each of the K true clusters
        pi_CI <- apply(analysis$pi_red[, order], 2, function(x) quantile(x, c(0.025, 0.975)))
        # Assign 1 if interval covers true value, 0 if not
        pi_cover[samp_n, ] <- ifelse((true_params$true_pi >= pi_CI[1,]) & 
                                       (true_params$true_pi <= pi_CI[2,]), 1, 0)
        
        ##### theta
        for (k in 1:K) {
          # Subset theta for cluster k
          est_theta_k <- analysis$theta_red[,,order[k],]
          # Each row provides the indices for one row of modal probabilities
          modal_idx <- cbind(rep(1:M, each=p), rep(1:p, times=M), rep(est_modes[, k], times=M))
          # estimated probabilities for the true mode for cluster k (Mxp)
          est_theta_k_modal <- matrix(est_theta_k[modal_idx], ncol=p, byrow=TRUE)
          # Obtain credible intervals for each item 
          # margins of apply are the dimensions that should be preserved
          theta_CI <- apply(est_theta_k_modal, 2, function(x) quantile(x, c(0.025, 0.975)))
          theta_cover[samp_n, , k] <- ifelse((true_theta_modal[,k] >= theta_CI[1,]) &
                                               (true_theta_modal[,k] <= theta_CI[2,]), 1, 0)
        }
        
        ##### xi
        # With factor variable coding
        xi_red_perm <- analysis$xi_red
        for (s in 1:S) {
          xi_red_perm[ , (s-1)*true_K + (1:true_K)] <- analysis$xi_red[ , (s-1)*true_K + order]
        }
        # Obtain credible intervals for each of the K true clusters
        xi_CI <- apply(xi_red_perm, 2, function(x) quantile(x, c(0.025, 0.975)))
        # Assign 1 if interval covers true value, 0 if not
        xi_cover[samp_n, ] <- ifelse((true_params$true_xi >= xi_CI[1,]) & 
                                       (true_params$true_xi <= xi_CI[2,]), 1, 0)        
      }
      
      ############### Parameter estimate plots ################
      ##### theta
      if (plot_theta) {
        if (analysis$k_red > sim_pop$true_K) { # mismatch of number of classes
          if (dim(theta_mode_all)[3] < analysis$k_red) {
            filler <- array(NA, dim=c(R, dim(analysis$theta_med)[1], extra))
            theta_mode_all <- abind(theta_mode_all, filler, along = 3)
          }
        } 
        theta_mode_all[i,,1:true_K] <- est_modes
        # Mode mismatches
        mode_mis_all[i] <- sum(abs(est_modes - sim_pop$true_global_patterns))
      }
      
      ##### pi
      if (plot_pi) {
        if (analysis$k_red > sim_pop$true_K) { # mismatch of number of classes
          if (dim(pi_all)[2] < analysis$k_red) {
            filler <- array(NA, dim=c(R, extra))
            pi_all <- abind(pi_all, filler, along = 2)
          }
        }
        pi_all[i,1:true_K] <- analysis$pi_med[order]
      }
      
      ##### xi
      if (plot_xi) {
        if (analysis$k_red > sim_pop$true_K) { # mismatch of number of classes
          if (dim(xi_all)[2] < (S * analysis$k_red)) {
            filler <- array(NA, dim=c(R, S * extra))
            xi_all <- abind(xi_all, filler, along = 2)
          }
        }
        for (s in 1:S) {
          xi_all[i, (s-1)*true_K + (1:true_K)] <- analysis$xi_med[(s-1)*true_K + order]
        }
      }
      
      # # Get dist for Phi
      # # Get true Phi for the sample
      # n <- length(sim_samp$true_Ci)
      # true_Phi <- numeric(n)
      # for (i in 1:n) {
      #   true_Phi[i] <- true_params$true_Phi_mat[sim_samp$true_Si[i], sim_samp$true_Ci[i]]
      # }
      # Phi_dist[samp_n] <- get_Phi_dist(analysis$Phi_med, true_Phi)$Phi_dist
      # Phi_dist_s[samp_n] <- get_Phi_dist(data_s$Phi_med, true_Phi)$Phi_dist
    }
  }
  # Obtain MSE by taking the mean over the independent samples
  K_MSE <- mean(K_dist, na.rm = TRUE)
  pi_MSE <- mean(pi_dist, na.rm = TRUE)
  theta_MSE <- mean(theta_dist, na.rm = TRUE)
  xi_MSE <- mean(xi_dist, na.rm = TRUE)

  # List of returns
  ret_list <- list(K_MSE = K_MSE, pi_MSE = pi_MSE, theta_MSE = theta_MSE, xi_MSE = xi_MSE)
  if (posthoc) {
    posthoc_pi_MSE <- mean(pi_dist_posthoc)
    ret_list[["posthoc_pi_MSE"]] <- posthoc_pi_MSE
  } 
  if (plot_pi) {
    ret_list[["pi_all"]] <- pi_all
  }
  if (plot_theta) {
    theta_mode <- apply(theta_mode_all, c(2,3), function(x) mean(x, na.rm = TRUE))
    mode_mis <- mean(mode_mis_all, na.rm = TRUE)
    ret_list[["theta_mode"]] <- theta_mode
    ret_list[["mode_mis"]] <- mode_mis
  }
  if (plot_xi) {
    ret_list[["xi_all"]] <- xi_all
  }
  
  if (coverage) {
    # Obtain cluster-specific coverage over the independent samples
    pi_cover_avg <- colMeans(pi_cover, na.rm = TRUE)
    # average over food items for theta
    theta_cover_avg <- colMeans(colMeans(theta_cover, na.rm = TRUE), na.rm = TRUE)
    xi_cover_avg <- colMeans(xi_cover, na.rm = TRUE)
    ret_list[["pi_cover_avg"]] <- pi_cover_avg
    ret_list[["theta_cover_avg"]] <- theta_cover_avg
    ret_list[["xi_cover_avg"]] <- xi_cover_avg
  }
  
  return(ret_list)
}


```


## MSE for posterior parameters: squared Euclidean distance averaged across samples

### Baseline scenario
```{r, echo=FALSE, cache=TRUE}
data_dir <- "/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Data/"
res_dir <- "/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Results/"
scen_pop=1
scen_samp=101
iter_pop=1
R_seq=1:100
posthoc=FALSE
coverage = TRUE
plot_pi =TRUE
plot_theta=TRUE
plot_xi=TRUE

MSE_SRS_ws <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=101, 
                      iter_pop=iter_pop, R_seq=R_seq, model="wsOFMM")
MSE_SRS_s <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=101, 
                      iter_pop=iter_pop, R_seq=R_seq, model="sOFMM")
MSE_SRS_unsup <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=101, 
                        iter_pop=iter_pop, R_seq=R_seq, model="wOFMM")
MSE_Strat_ws <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=201, 
                        iter_pop=iter_pop, R_seq=R_seq, model="wsOFMM")
MSE_Strat_s <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=201, 
                       iter_pop=iter_pop, R_seq=R_seq, model="sOFMM")
MSE_Strat_unsup <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=1, scen_samp=201, 
                           iter_pop=iter_pop, R_seq=R_seq, model="wOFMM")
```

### Create table

```{r, echo=FALSE}
### Create table of MSEs
MSE_summ <- as.data.frame(matrix(NA, nrow=6, ncol=6))
colnames(MSE_summ) <- c("Sampling Scheme", "Model", "K", "$\\pi$", "$\\theta$", "$\\xi$")
MSE_summ[, 1] <- c(rep("SRS", 3), rep("Stratified", 3))
MSE_summ[, 2] <- rep(c("Unweighted(sOFMM)", "Weighted(wsOFMM)", "Unsupervised(wOFMM)"), 2)  ## latent versions
MSE_summ[1, -c(1,2)] <- c(MSE_SRS_s[1:4])
MSE_summ[2, -c(1,2)] <- c(MSE_SRS_ws[1:4])
MSE_summ[3, -c(1,2)] <- c(MSE_SRS_unsup[1:4])
MSE_summ[4, -c(1,2)] <- c(MSE_Strat_s[1:4])
MSE_summ[5, -c(1,2)] <- c(MSE_Strat_ws[1:4])
MSE_summ[6, -c(1,2)] <- c(MSE_Strat_unsup[1:4])

MSE_summ %>% 
  gt(caption = "Baseline scenario MSE of posterior parameter estimates, averaged over 100 samples") %>%
  cols_label("$\\pi$" = "π", "$\\theta$" = "θ", "$\\xi$" = "ξ") %>%
  fmt_scientific(
    columns = 3:6,
    decimals = 3
  ) 
  
```

### Coverage plots
```{r, echo=FALSE}
plot_pi_cov <- data.frame(
  coverage = c(MSE_SRS_s$pi_cover_avg, MSE_SRS_ws$pi_cover_avg, 
               MSE_Strat_s$pi_cover_avg, MSE_Strat_ws$pi_cover_avg),
  pi = rep(c("pi (k=1)", "pi (k=2)", "pi (k=3)"), times=4),
  model = rep(rep(c("SOLCA (Unweighted)", "WSOLCA (Weighted)"), each=3), times=2),
  sampling = rep(c("SRS", "Stratified"), each=6)
)
pi_plot <- plot_pi_cov %>%  ggplot(aes(x=pi, y=coverage, color=model)) +
  theme_bw() +
  labs(x = expression(pi), y = "Coverage", color = "Model") +
  geom_point(size=2.5, position = position_dodge(0.3)) + 
  geom_hline(aes(yintercept=0.95)) +
  scale_y_continuous(limits=c(0,1), breaks=sort(c(seq(0, 1, length.out=5), 0.95))) + 
  facet_grid(~sampling)

plot_theta_cov <- data.frame(
  coverage = c(MSE_SRS_s$theta_cover_avg, MSE_SRS_ws$theta_cover_avg, 
               MSE_Strat_s$theta_cover_avg, MSE_Strat_ws$theta_cover_avg),
  theta = rep(c("theta_1", "theta_2", "theta_3"), times=4),
  model = rep(rep(c("SOLCA (Unweighted)", "WSOLCA (Weighted)"), each=3), times=2),
  sampling = rep(c("SRS", "Stratified"), each=6)
)
theta_plot <- plot_theta_cov %>%  ggplot(aes(x=theta, y=coverage, color=model)) +
  theme_bw() +
  labs(x = expression(theta), y = "Coverage", color = "Model") +
  geom_point(size=2.5, position = position_dodge(0.3)) + 
  geom_hline(aes(yintercept=0.95)) +
  scale_y_continuous(limits=c(0,1), breaks=sort(c(seq(0, 1, length.out=5), 0.95))) + 
  facet_grid(~sampling)

plot_xi_cov <- data.frame(
  coverage = c(MSE_SRS_s$xi_cover_avg, MSE_SRS_ws$xi_cover_avg, 
               MSE_Strat_s$xi_cover_avg, MSE_Strat_ws$xi_cover_avg),
  xi = rep(c("xi_1", "xi_2", "xi_3", "xi_4", "xi_5", "xi_6"), times=4),
  model = rep(rep(c("SOLCA (Unweighted)", "WSOLCA (Weighted)"), each=6), times=2),
  sampling = rep(c("SRS", "Stratified"), each=12)
)
xi_plot <- plot_xi_cov %>%  ggplot(aes(x=xi, y=coverage, color=model)) +
  theme_bw() +
  labs(x = expression(xi), y = "Coverage", color = "Model") +
  geom_point(size=2.5, position = position_dodge(0.3)) + 
  geom_hline(aes(yintercept=0.95)) +
  scale_y_continuous(limits=c(0,1), breaks=sort(c(seq(0, 1, length.out=5), 0.95))) + 
  facet_grid(~sampling)


ggarrange(pi_plot, theta_plot, nrow = 1, common.legend = TRUE, legend = "top")
xi_plot
```


### Plot pi as grouped boxplot over iterations

```{r, echo=FALSE}
data_dir <- "/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Data/"
scen_pop=1
iter_pop=1
sim_pop <- readMat(paste0(data_dir, "simdata_scen", scen_pop,"_iter", iter_pop, ".mat"))$sim.data
names(sim_pop) <- str_replace_all(dimnames(sim_pop)[[1]], "[.]", "_")

# Obtain true observed population parameters
true_params <- get_true_params(sim_pop)

R <- length(R_seq)
pi_plot_data <- as.data.frame(rbind(MSE_Strat_s$pi_all,  MSE_Strat_ws$pi_all, MSE_Strat_unsup$pi_all))
if (any(is.na(pi_plot_data))) {
  colnames(pi_plot_data) <- paste0("pi_", 1:ncol(pi_plot_data))
  pi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R), rep("wOFMM", times=R))
  pi_plot_data <- pi_plot_data %>% gather("pi_component", "value", -Model)
  pi_plot_data <- pi_plot_data %>% 
    group_by(Model, pi_component) %>% 
    mutate(num_points = sum(!is.na(value)))
  ggplot(pi_plot_data, aes(x=pi_component, y=value, fill=Model, alpha=factor(num_points))) +
    theme_bw() +
    geom_boxplot() +
    scale_alpha_discrete(range = c(0.2, 1), guide = guide_legend(override.aes = list(fill = "black"),
                         title = "Number of Observations")) +
    geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_params$true_pi[1],
                             yend=true_params$true_pi[1]),color="forestgreen") +
    geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_params$true_pi[2],
                             yend=true_params$true_pi[2]),color="forestgreen") +
    geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_params$true_pi[3],
                             yend=true_params$true_pi[3]),color="forestgreen") +
    ggtitle("Parameter estimation for pi under stratified sampling with 
            \nunequal probabilities, displayed across 100 samples")
} else {
  colnames(pi_plot_data) <- paste0("pi_", 1:ncol(pi_plot_data))
  pi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R), rep("wOFMM", times=R))
  pi_plot_data <- pi_plot_data %>% gather("pi_component", "value", -Model)
  ggplot(pi_plot_data, aes(x=pi_component, y=value, fill=Model)) +
    theme_bw() +
    geom_boxplot() +
    geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_params$true_pi[1],
                             yend=true_params$true_pi[1]),color="forestgreen") +
    geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_params$true_pi[2],
                             yend=true_params$true_pi[2]),color="forestgreen") +
    geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_params$true_pi[3],
                             yend=true_params$true_pi[3]),color="forestgreen") +
    ggtitle("Parameter estimation for pi under stratified sampling with 
            \nunequal probabilities, displayed across 100 samples")
}

```

### Plot xi over 100 iterations

```{r, echo=FALSE}
xi_plot_data <- as.data.frame(rbind(MSE_Strat_s$xi_all,  MSE_Strat_ws$xi_all, MSE_Strat_unsup$xi_all))
colnames(xi_plot_data) <- paste0("xi_", 1:ncol(xi_plot_data))
xi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R), rep("wOFMM", times=R))
xi_plot_data <- xi_plot_data %>% gather("xi_component", "value", -Model)
ggplot(xi_plot_data, aes(x=xi_component, y=value, fill=Model)) +
  theme_bw() +
  geom_boxplot() +
  geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_params$true_xi[1], yend=true_params$true_xi[1]),color="forestgreen") +
  geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_params$true_xi[2], yend=true_params$true_xi[2]),color="forestgreen") +
  geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_params$true_xi[3], yend=true_params$true_xi[3]),color="forestgreen") +
  geom_segment(mapping=aes(x=3.5, xend=4.5, y=true_params$true_xi[4], yend=true_params$true_xi[4]),color="forestgreen") +
  geom_segment(mapping=aes(x=4.5, xend=5.5, y=true_params$true_xi[5], yend=true_params$true_xi[5]),color="forestgreen") +
  geom_segment(mapping=aes(x=5.5, xend=6.5, y=true_params$true_xi[6], yend=true_params$true_xi[6]),color="forestgreen") +
  ggtitle("Parameter estimation for xi under stratified sampling with unequal probabilities, \ndisplayed across 100 samples")

```

### Plot Phi over 100 iterations

```{r, echo=FALSE}
Phi_plot_data <- as.data.frame(rbind(pnorm(MSE_Strat_s$xi_all),  pnorm(MSE_Strat_ws$xi_all), 
                                     pnorm(MSE_Strat_unsup$xi_all)))
colnames(Phi_plot_data) <- c("(S=1,C=1)", "(S=1,C=2)", "(S=1,C=3)", "(S=2,C=1)", "(S=2,C=2)", "(S=2,C=3)")
Phi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R), rep("wOFMM", times=R))
Phi_plot_data <- Phi_plot_data %>% gather("Phi_component", "value", -Model)
true_Phi <- pnorm(true_params$true_xi)
ggplot(Phi_plot_data, aes(x=Phi_component, y=value, fill=Model)) +
  theme_bw() +
  geom_boxplot() +
  ylab("P(Y=1|S,C)") +
  geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_Phi[1], yend=true_Phi[1]),color="forestgreen") +
  geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_Phi[2], yend=true_Phi[2]),color="forestgreen") +
  geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_Phi[3], yend=true_Phi[3]),color="forestgreen") +
  geom_segment(mapping=aes(x=3.5, xend=4.5, y=true_Phi[4], yend=true_Phi[4]),color="forestgreen") +
  geom_segment(mapping=aes(x=4.5, xend=5.5, y=true_Phi[5], yend=true_Phi[5]),color="forestgreen") +
  geom_segment(mapping=aes(x=5.5, xend=6.5, y=true_Phi[6], yend=true_Phi[6]),color="forestgreen") +
  ggtitle("Parameter estimation for Phi under stratified sampling with unequal probabilities, \ndisplayed across 100 samples")

```

### Plot theta over 100 iteraitons

```{r, echo=FALSE}
theta_mode_plot <- function(theta_plot_data, x_label) {
  p <- dim(theta_plot_data)[1]
  K <- dim(theta_plot_data)[2]
  Item <- factor(as.character(1:p), levels = as.character(p:1))
  theta_plot_data <- data.frame(theta_plot_data, Item)
  colnames(theta_plot_data) <- c(1:3, "Item")
  theta_plot_data <- theta_plot_data %>% gather("Class", "Level", 1:3) 
  patterns <- ggplot(theta_plot_data, aes(x=Class, y=Item, fill=Level)) + 
            theme_classic() +
            xlab(x_label) +
            geom_tile(color="gray") + 
            geom_text(aes(label = Level), col="white", cex=2) +
            scale_fill_gradient(trans = "reverse")
  return(patterns)
}

p_true <- theta_mode_plot(sim_pop$true_global_patterns, "True Classes")
p_sOFMM <- theta_mode_plot(MSE_Strat_s$theta_mode, "sOFMM Classes")
p_wsOFMM <- theta_mode_plot(MSE_Strat_ws$theta_mode, "wsOFMM Classes")
p_wOFMM <- theta_mode_plot(MSE_Strat_unsup$theta_mode, "wOFMM Classes")
p_comb <- ggarrange(p_true, p_sOFMM + theme(axis.title.y = element_blank()), 
                    p_wsOFMM + theme(axis.title.y = element_blank()),
                    p_wOFMM + theme(axis.title.y = element_blank()), 
                    nrow = 1, common.legend = TRUE, legend = "right")
annotate_figure(p_comb, 
  top = text_grob("Pattern elicitation under stratified sampling with unequal probabilities, averaged across 100 samples"))
```




## Supervised scenario

```{r, echo=FALSE, cache=TRUE}
MSE_Sup_SRS_ws <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=102, 
                      iter_pop=iter_pop, R_seq=R_seq, model="wsOFMM")
MSE_Sup_SRS_s <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=102, 
                      iter_pop=iter_pop, R_seq=R_seq, model="sOFMM")
MSE_Sup_SRS_unsup <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=102, 
                            iter_pop=iter_pop, R_seq=R_seq, model="wOFMM")
MSE_Sup_Strat_ws <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=202, 
                      iter_pop=iter_pop, R_seq=R_seq, model="wsOFMM")
MSE_Sup_Strat_s <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=202, 
                     iter_pop=iter_pop, R_seq=R_seq, model="sOFMM")
MSE_Sup_Strat_unsup <- get_MSE(data_dir=data_dir, res_dir=res_dir, scen_pop=2, scen_samp=202, 
                              iter_pop=iter_pop, R_seq=R_seq, model="wOFMM")
```

#### Create table

```{r, echo=FALSE}
### Create table of MSEs
MSE_summ <- as.data.frame(matrix(NA, nrow=6, ncol=6))
colnames(MSE_summ) <- c("Sampling Scheme", "Model", "K", "$\\pi$", "$\\theta$", "$\\xi$")
MSE_summ[, 1] <- c(rep("SRS", 3), rep("Stratified", 3))
MSE_summ[, 2] <- rep(c("Unweighted(sOFMM)", "Weighted(wsOFMM)", "Unsupervised(wOFMM)"), 2)  ## latent versions
MSE_summ[1, -c(1,2)] <- c(MSE_Sup_SRS_s[1:4])
MSE_summ[2, -c(1,2)] <- c(MSE_Sup_SRS_ws[1:4])
MSE_summ[3, -c(1,2)] <- c(MSE_Sup_SRS_unsup[1:4])
MSE_summ[4, -c(1,2)] <- c(MSE_Sup_Strat_s[1:4])
MSE_summ[5, -c(1,2)] <- c(MSE_Sup_Strat_ws[1:4])
MSE_summ[6, -c(1,2)] <- c(MSE_Sup_Strat_unsup[1:4])

MSE_summ %>% 
  gt(caption = "Supervised scenario MSE of posterior parameter estimates, averaged over 100 samples") %>%
  cols_label("$\\pi$" = "π", "$\\theta$" = "θ", "$\\xi$" = "ξ") %>%
  fmt_scientific(
    columns = 3:6,
    decimals = 3
  ) 
  
```

#### Plot pi as grouped boxplot over iterations

```{r, echo=FALSE}
data_dir <- "/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Data/"
scen_pop=2
iter_pop=1
sim_pop <- readMat(paste0(data_dir, "simdata_scen", scen_pop,"_iter", iter_pop, ".mat"))$sim.data
names(sim_pop) <- str_replace_all(dimnames(sim_pop)[[1]], "[.]", "_")

# Obtain true observed population parameters
true_params <- get_true_params(sim_pop)


R <- length(R_seq)
pi_plot_data <- as.data.frame(rbind(MSE_Sup_Strat_s$pi_all,  MSE_Sup_Strat_ws$pi_all, MSE_Sup_Strat_unsup$pi_all))
if (any(is.na(pi_plot_data))) {
  colnames(pi_plot_data) <- paste0("pi_", 1:ncol(pi_plot_data))
  pi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R), rep("wOFMM", times=R))
  pi_plot_data <- pi_plot_data %>% gather("pi_component", "value", -Model)
  pi_plot_data <- pi_plot_data %>% group_by(Model, pi_component) %>% mutate(num_points = sum(!is.na(value)))
  ggplot(pi_plot_data, aes(x=pi_component, y=value, fill=Model, alpha=factor(num_points))) +
    theme_bw() +
    geom_boxplot() +
    scale_alpha_discrete(range = c(0.2, 1), guide = guide_legend(override.aes = list(fill = "black"),
                         title = "Number of Observations")) +
    geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_params$true_pi[1], yend=true_params$true_pi[1]),color="forestgreen") +
    geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_params$true_pi[2], yend=true_params$true_pi[2]),color="forestgreen") +
    geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_params$true_pi[3], yend=true_params$true_pi[3]),color="forestgreen") +
    ggtitle("Parameter estimation for pi under stratified sampling with \nunequal probabilities, displayed across 100 samples")
} else {
  colnames(pi_plot_data) <- paste0("pi_", 1:ncol(pi_plot_data))
  pi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R), rep("wOFMM", times=R))
  pi_plot_data <- pi_plot_data %>% gather("pi_component", "value", -Model)
  ggplot(pi_plot_data, aes(x=pi_component, y=value, fill=Model)) +
    theme_bw() +
    geom_boxplot() +
    geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_params$true_pi[1], yend=true_params$true_pi[1]),color="forestgreen") +
    geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_params$true_pi[2], yend=true_params$true_pi[2]),color="forestgreen") +
    geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_params$true_pi[3], yend=true_params$true_pi[3]),color="forestgreen") +
    ggtitle("Parameter estimation for pi under stratified sampling with \nunequal probabilities, displayed across 100 samples")
}

```

### Plot xi over 100 iterations

```{r, echo=FALSE}
xi_plot_data <- as.data.frame(rbind(MSE_Sup_Strat_s$xi_all,  MSE_Sup_Strat_ws$xi_all, MSE_Sup_Strat_unsup$xi_all))
colnames(xi_plot_data) <- paste0("xi_", 1:ncol(xi_plot_data))
xi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R), rep("wOFMM", times=R))
xi_plot_data <- xi_plot_data %>% gather("xi_component", "value", -Model)
ggplot(xi_plot_data, aes(x=xi_component, y=value, fill=Model)) +
  theme_bw() +
  geom_boxplot() +
  geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_params$true_xi[1], yend=true_params$true_xi[1]),color="forestgreen") +
  geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_params$true_xi[2], yend=true_params$true_xi[2]),color="forestgreen") +
  geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_params$true_xi[3], yend=true_params$true_xi[3]),color="forestgreen") +
  geom_segment(mapping=aes(x=3.5, xend=4.5, y=true_params$true_xi[4], yend=true_params$true_xi[4]),color="forestgreen") +
  geom_segment(mapping=aes(x=4.5, xend=5.5, y=true_params$true_xi[5], yend=true_params$true_xi[5]),color="forestgreen") +
  geom_segment(mapping=aes(x=5.5, xend=6.5, y=true_params$true_xi[6], yend=true_params$true_xi[6]),color="forestgreen") +
  ggtitle("Parameter estimation for xi under stratified sampling with unequal probabilities, \ndisplayed across 100 samples")

```

### Plot Phi over 100 iterations

```{r, echo=FALSE}
Phi_plot_data <- as.data.frame(rbind(pnorm(MSE_Sup_Strat_s$xi_all),  pnorm(MSE_Sup_Strat_ws$xi_all), 
                                     pnorm(MSE_Sup_Strat_unsup$xi_all)))
colnames(Phi_plot_data) <- c("(S=1,C=1)", "(S=1,C=2)", "(S=1,C=3)", "(S=2,C=1)", "(S=2,C=2)", "(S=2,C=3)")
Phi_plot_data$Model <- c(rep("sOFMM", times=R), rep("wsOFMM", times=R), rep("wOFMM", times=R))
Phi_plot_data <- Phi_plot_data %>% gather("Phi_component", "value", -Model)
true_Phi <- pnorm(true_params$true_xi)
ggplot(Phi_plot_data, aes(x=Phi_component, y=value, fill=Model)) +
  theme_bw() +
  geom_boxplot() +
  ylab("P(Y=1|S,C)") +
  geom_segment(mapping=aes(x=0.5, xend=1.5, y=true_Phi[1], yend=true_Phi[1]),color="forestgreen") +
  geom_segment(mapping=aes(x=1.5, xend=2.5, y=true_Phi[2], yend=true_Phi[2]),color="forestgreen") +
  geom_segment(mapping=aes(x=2.5, xend=3.5, y=true_Phi[3], yend=true_Phi[3]),color="forestgreen") +
  geom_segment(mapping=aes(x=3.5, xend=4.5, y=true_Phi[4], yend=true_Phi[4]),color="forestgreen") +
  geom_segment(mapping=aes(x=4.5, xend=5.5, y=true_Phi[5], yend=true_Phi[5]),color="forestgreen") +
  geom_segment(mapping=aes(x=5.5, xend=6.5, y=true_Phi[6], yend=true_Phi[6]),color="forestgreen") +
  ggtitle("Parameter estimation for Phi under stratified sampling with unequal probabilities, \ndisplayed across 100 samples")

```

### Plot theta over 100 iteraitons

```{r, echo=FALSE}
theta_mode_plot <- function(theta_plot_data, x_label) {
  p <- dim(theta_plot_data)[1]
  K <- dim(theta_plot_data)[2]
  Item <- factor(as.character(1:p), levels = as.character(p:1))
  theta_plot_data <- data.frame(theta_plot_data, Item)
  colnames(theta_plot_data) <- c(1:3, "Item")
  theta_plot_data <- theta_plot_data %>% gather("Class", "Level", 1:3) 
  patterns <- ggplot(theta_plot_data, aes(x=Class, y=Item, fill=Level)) + 
            theme_classic() +
            xlab(x_label) +
            geom_tile(color="gray") + 
            geom_text(aes(label = Level), col="white", cex=2) +
            scale_fill_gradient(trans = "reverse")
  return(patterns)
}

p_true <- theta_mode_plot(sim_pop$true_global_patterns, "True Classes")
p_sOFMM <- theta_mode_plot(MSE_Sup_Strat_s$theta_mode, "sOFMM Classes")
p_wsOFMM <- theta_mode_plot(MSE_Sup_Strat_ws$theta_mode, "wsOFMM Classes")
p_wOFMM <- theta_mode_plot(MSE_Sup_Strat_unsup$theta_mode, "wOFMM Classes")
p_comb <- ggarrange(p_true, p_sOFMM + theme(axis.title.y = element_blank()), 
                    p_wsOFMM + theme(axis.title.y = element_blank()),
                    p_wOFMM + theme(axis.title.y = element_blank()), 
                    nrow = 1, common.legend = TRUE, legend = "right")
annotate_figure(p_comb, 
  top = text_grob("Pattern elicitation under stratified sampling with unequal probabilities, averaged across 100 samples"))
```







