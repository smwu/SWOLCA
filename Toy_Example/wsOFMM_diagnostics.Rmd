---
title: "wsOFMM Diagnostics"
author: "Stephanie Wu"
date: "3/3/2022"
output: pdf_document
---
```{r, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE}
library(R.matlab)
library(ggplot2)
library(gridExtra)
library(ggpubr)
library(dplyr)
library(plyr)
library(tidyr)
library(rstan)
library(bayesplot)
library(coda)
library(gtools)


# Load and prepare data
setwd("C:/Users/Lang/Documents/Harvard/Research/Briana/supRPC/wsOFMM/Toy_Example")
# setwd("/n/holyscratch01/stephenson_lab/Users/stephwu18/wsOFMM/Summary_Results")

#============================== Code for Graphics ======================================

## Loading data
get_dataframes <- function(scen, iter, samp_n, latent=TRUE) {
  # Simulated data
  pop_data <- readMat(paste0("simdata_scen2_iter", iter, ".mat"))$sim.data
  samp_data <- readMat(paste0("simdata_scen14_iter", iter, "_samp", samp_n, ".mat"))$sim.data
  names(pop_data) <- c("true_pi", "true_xi", "true_global_patterns", "true_global_thetas", "samp_ind", 
                       "sample_wt", "norm_const", "true_Si", "true_Ci", "X_data", "Y_data",
                       "true_Phi", "true_K")
  names(samp_data) <- c(names(pop_data), "true_Li")
  
  # Model output
  if (latent) {
    data_ws <- readMat(paste0("wsOFMM_latent_results_scen", scen, "_iter", iter, 
                          "_samp", samp_n, ".mat"))
    data_s <- readMat(paste0("sOFMM_latent_results_scen", scen, "_iter", iter, 
                         "_samp", samp_n, ".mat"))
  } else {
    data_ws <- readMat(paste0("wsOFMM_results_scen", scen, "_iter", iter, 
                          "_samp", samp_n, ".mat"))
    data_s <- readMat(paste0("sOFMM_results_scen", scen, "_iter", iter, 
                         "_samp", samp_n, ".mat"))
  }
  
  data_ws <- data_ws$analysis
  data_s <- data_s$analysis
  names(data_ws) <- c("pi_med", "theta_med", "xi_med", "k_red", "pi_red", "theta_red", 
                      "xi_red", "c_i", "Phi_med", "z_i", "loglik_med", "dic6", "aebic")
  names(data_s) <- c(names(data_ws), "posthoc_pi")
  
  K_match_ws <- data_ws$k_red == pop_data$true_K
  K_match_s <- data_s$k_red == pop_data$true_K
  if (K_match_ws && K_match_s) {
    # Create dataframe to analyze MCMC chains
  
    df_ws <- data.frame(data_ws$pi_red, data_ws$theta_red, data_ws$xi_red)
    df_s <- data.frame(data_s$pi_red, data_s$theta_red, data_s$xi_red)
    
    # Assuming both models have same number of components
    pi_dim <- ncol(data_ws$pi_red)
    theta_dim <- dim(data_ws$theta_red)
    theta_names <- paste0(paste0(paste0("theta_", 1:theta_dim[2]), 
                                 "_", rep(1:theta_dim[3], each=theta_dim[2])), 
                          "_", rep(1:theta_dim[4], each=(theta_dim[2]*theta_dim[3])))
    xi_dim <- ncol(data_ws$xi_red)
    colnames(df_ws) <- colnames(df_s) <- c(paste0("pi_", 1:pi_dim),
                                           theta_names,
                                           paste0("xi_", 1:xi_dim))
    return(list("data_ws"=data_ws, "data_s"=data_s, "df_ws"=df_ws, "df_s"=df_s, 
                "theta_names"=theta_names, "pi_dim"=pi_dim, "xi_dim"=xi_dim,
                "pop_data"=pop_data, "samp_data"=samp_data))
  } else {
    print(paste0("Iteration ", iter, " wsOFMM K=", data_ws$k_red, " and sOFMM K=", data_s$k_red))
    return(NULL)
  }
}


## Plotting
plot_params <- function(df_s, df_ws, dataframes, iter) {
  combined_df <- rbind(df_s, df_ws)
  combined_df$Model <- c(rep("sOFMM", times=nrow(df_s)), rep("wsOFMM", times=nrow(df_ws)))
  
  pi_dim <- ncol(dataframes$data_ws$pi_red)
  xi_dim <- ncol(dataframes$data_ws$xi_red)
  reshape_df <- combined_df %>% gather("pi", "pi_value", 1:dataframes$pi_dim) %>%
    gather("theta", "theta_value", 1:length(dataframes$theta_names)) %>%
    gather("xi", "xi_value", 1:dataframes$xi_dim)
  
  # Create dataframe of point estimates for post-hoc sOFMM and wsOFMM
  posthoc_df <- data.frame(paste0("pi_", 1:pi_dim), dataframes$data_s$posthoc_pi)
  colnames(posthoc_df) <- c("pi", "pi_value")
  wsOFMM_pi_med <- data.frame(paste0("pi_", 1:pi_dim), t(dataframes$data_ws$pi_med))
  colnames(wsOFMM_pi_med) <- c("pi", "pi_value")
  point_df <- rbind(posthoc_df, wsOFMM_pi_med)
  point_df$Model <- c(rep("sOFMM", times=nrow(posthoc_df)), rep("wsOFMM", times=nrow(wsOFMM_pi_med)))
  
  # Plot comparing pi for wsOFMM and sOFMM, with true values in green and sample values in red
  
  pi_plot <- reshape_df %>% ggplot(aes(x=pi, y=pi_value, fill=Model)) + 
    geom_boxplot() +
    ggtitle(paste0("Parameter comparison for pi for iteration ", iter)) +
    theme(legend.position="top", plot.title = element_text(hjust = 0.5)) + 
    geom_hline(yintercept= (sum(dataframes$pop_data[[9]]==1)/nrow(dataframes$pop_data[[9]])), linetype="dashed", color="forestgreen") + 
    geom_hline(yintercept= (sum(dataframes$pop_data[[9]]==2)/nrow(dataframes$pop_data[[9]])), linetype="dashed", color="forestgreen") + 
    geom_hline(yintercept= (sum(dataframes$samp_data[[9]]==1)/nrow(dataframes$samp_data[[9]])), linetype="dashed", color="red") +
    geom_hline(yintercept= (sum(dataframes$samp_data[[9]]==2)/nrow(dataframes$samp_data[[9]])), linetype="dashed", color="red")
  pi_plot + geom_point(data=point_df, aes(x=pi, y=pi_value, color=Model), inherit.aes = FALSE, size=5)
  
  
  # Plot comparing theta for wsOFMM and sOFMM, with true values in green
  theta_dim <- dim(dataframes$data_ws$theta_red)
  theta_labels <- paste0(paste0(paste0(1:theta_dim[2]), 
                               "_", rep(1:theta_dim[3], each=theta_dim[2])), 
                        "_", rep(1:theta_dim[4], each=(theta_dim[2]*theta_dim[3])))
  true_thetas <- as.numeric(names(table(dataframes$pop_data$true_global_thetas)))
  reshape_df %>% ggplot(aes(x=theta, y=theta_value, fill=Model)) + 
    geom_boxplot() +
    ggtitle(paste0("Parameter comparison for theta for iteration 1")) +
    theme(legend.position="top", plot.title = element_text(hjust = 0.5)) + 
    geom_hline(yintercept= true_thetas[1], linetype="dashed", color="forestgreen") + 
    geom_hline(yintercept= true_thetas[2], linetype="dashed", color="forestgreen") +
    scale_x_discrete(labels=theta_labels) + 
    theme(axis.text.x=element_text(angle=40)) + 
    xlab("theta(j,k,r)")
  
  # Plot comparing median xi for wsOFMM and sOFMM, with true values in green
  
  reshape_df %>% ggplot(aes(xi, y=xi_value, fill=Model)) + geom_boxplot() +
    ggtitle(paste0("Parameter comparison for xi for iteration 1")) +
    theme(legend.position="top", plot.title = element_text(hjust = 0.5)) +
    geom_hline(yintercept=dataframes$pop_data[[2]][1], linetype="dashed", color="forestgreen") + 
    geom_hline(yintercept=dataframes$pop_data[[2]][2], linetype="dashed", color="forestgreen") +
    geom_hline(yintercept=dataframes$pop_data[[2]][3], linetype="dashed", color="forestgreen") +
    geom_hline(yintercept=dataframes$pop_data[[2]][4], linetype="dashed", color="forestgreen") 
}


## MSE Summaries
get_MSE <- function(scen, iter_seq, samp_n, weighted=TRUE, post_hoc=FALSE) {
  
  ### Assuming K=true_K for both models
  MSE_df <- as.data.frame(matrix(NA, nrow=length(iter_seq), ncol=4))
  colnames(MSE_df) <- c("MSE_pi", "MSE_theta", "MSE_xi", "MSE_Phi")
  
  for (i in 1:length(iter_seq)) {
    iter <- iter_seq[i]
    dataframes <- get_dataframes(scen, iter, samp_n)
    
    if (!is.null(dataframes)) {
      if (weighted) {
        model_data <- dataframes$data_ws
      } else {
        model_data <- dataframes$data_s
      }
      
      # SSE for pi
      true_pi <- sort(c(sum(dataframes$pop_data$true_Ci==1) / 
                          nrow(dataframes$pop_data$true_Ci),
                      sum(dataframes$pop_data$true_Ci==2) / 
                        nrow(dataframes$pop_data$true_Ci)))
      if (post_hoc) {
        MSE_df$MSE_pi[i] <- sum((sort(model_data$posthoc_pi) - true_pi)^2)  # SSE
      } else {
        MSE_df$MSE_pi[i] <- sum((sort(model_data$pi_med) - true_pi)^2)  # SSE
      }
      
      # SSE for theta
      #dataframes$data_ws$theta_med
      
      # SSE for
      MSE_df$MSE_Phi[i] <- sum((model_data$Phi_med - dataframes$samp_data$true_Phi)^2)
    }
  }
  
  return(MSE_df)
}

```

## MCMC Diagnostics

```{r, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE}
scen <- 14
iter <- 1
samp_n <- 1

dataframes_1 <- get_dataframes(scen, iter, samp_n)
df_ws_1 <- dataframes_1$df_ws
df_s_1 <- dataframes_1$df_s

mcmc_trace(df_ws_1) + ggtitle(paste0("Trace Plots for wsOFMM Iteration ", iter))
mcmc_trace(df_s_1) + ggtitle(paste0("Trace Plots for sOFMM Iteration ", iter))

mcmc_acf(df_ws_1, lags = 10) + ggtitle(paste0("Autocorrelation Plots for wsOFMM Iteration ", iter))
mcmc_acf(df_s_1, lags=10) + ggtitle(paste0("Autocorrelation Plots for wsOFMM Iteration ", iter))


iter <- 11
dataframes_11 <- get_dataframes(scen, iter, samp_n)
df_ws_11 <- dataframes_11$df_ws
df_s_11 <- dataframes_11$df_s

mcmc_trace(df_ws_11) + ggtitle(paste0("Trace Plots for wsOFMM Iteration ", iter))
mcmc_trace(df_s_11) + ggtitle(paste0("Trace Plots for sOFMM Iteration ", iter))

### Not latent version
dataframes_11 <- get_dataframes(scen, iter, samp_n, latent=FALSE)
df_ws_11 <- dataframes_11$df_ws
df_s_11 <- dataframes_11$df_s

mcmc_trace(df_ws_11) + ggtitle(paste0("Trace Plots for wsOFMM Iteration ", iter))
mcmc_trace(df_s_11) + ggtitle(paste0("Trace Plots for sOFMM Iteration ", iter))

mcmc_acf(df_ws_1, lags = 10) + ggtitle(paste0("Autocorrelation Plots for wsOFMM Iteration ", iter))
mcmc_acf(df_s_1, lags=10) + ggtitle(paste0("Autocorrelation Plots for wsOFMM Iteration ", iter))

iter <- 20
dataframes_20 <- get_dataframes(scen, iter, samp_n)
df_ws_20 <- dataframes_20$df_ws
df_s_20 <- dataframes_20$df_s

mcmc_trace(df_ws_20) + ggtitle(paste0("Trace Plots for wsOFMM Iteration ", iter))
mcmc_trace(df_s_20) + ggtitle(paste0("Trace Plots for sOFMM Iteration ", iter))

```


## Posterior Parameter Estimates and Variance

```{r, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE}

plot_params(df_s_1, df_ws_1, dataframes_1, iter)
plot_params(df_s_11, df_ws_11, dataframes_11, iter)
plot_params(df_s_20, df_ws_20, dataframes_20, iter)

```


## MSE Summaries across Iterations

```{r, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE}
iter_seq <- 1:20
MSE_df_ws <- get_MSE(scen, iter_seq, samp_n, weighted=TRUE)
MSE_df_s <- get_MSE(scen, iter_seq, samp_n, weighted=FALSE)
MSE_df_s_post <- get_MSE(scen, iter_seq, samp_n, weighted=FALSE, post_hoc=TRUE)

print("wsOFMM")
colMeans(MSE_df_ws, na.rm=TRUE)
print("sOFMM")
colMeans(MSE_df_s, na.rm=TRUE)
print("sOFMM with posthoc adjustment")
colMeans(MSE_df_s_post, na.rm=TRUE)
```
